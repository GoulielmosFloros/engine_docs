"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8491],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=a,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||r;return n?o.createElement(m,i(i({ref:t},d),{},{components:n})):o.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9842:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],s={},l=void 0,p={unversionedId:"Tutorials/Components/Core/IfcRelationsIndexer",id:"Tutorials/Components/Core/IfcRelationsIndexer",title:"IfcRelationsIndexer",description:"Copying and pasting? We've got you covered! You can find the full source code of this tutorial here.",source:"@site/docs/Tutorials/Components/Core/IfcRelationsIndexer.mdx",sourceDirName:"Tutorials/Components/Core",slug:"/Tutorials/Components/Core/IfcRelationsIndexer",permalink:"/Tutorials/Components/Core/IfcRelationsIndexer",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IfcPropertiesTiler",permalink:"/Tutorials/Components/Core/IfcPropertiesTiler"},next:{title:"MiniMap",permalink:"/Tutorials/Components/Core/MiniMap"}},d={},c=[{value:"Getting entity relations the easy way \ud83d\udcaa",id:"getting-entity-relations-the-easy-way-",level:2},{value:"Loading a model \ud83c\udfe6",id:"loading-a-model-",level:3},{value:"Getting element psets \ud83d\udcc4",id:"getting-element-psets-",level:3},{value:"Exporting the indexation",id:"exporting-the-indexation",level:3},{value:"Loading back the relations index",id:"loading-back-the-relations-index",level:3}],u={toc:c},h="wrapper";function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)(h,(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"Source",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ThatOpen/engine_components/blob/main/packages/core/src/ifc/IfcRelationsIndexer/example.ts"},"here"),".")),(0,r.kt)("h2",{id:"getting-entity-relations-the-easy-way-"},"Getting entity relations the easy way \ud83d\udcaa"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"If you're aware of the IFC schema, you should know that all the possible information an entity have is not directly inside its attributes. For example, the property sets, classifications, materials, etc, of a wall (or any other element) are not directly in the wall attributes \ud83e\udd2f but in other entities which are related to the wall using relations.\nNow, that is perfect for an schema like the IFC which aims to store all the building data within a single text file in the easiest way possible. However, is not that easy to work just because you need to find the relations you want to get to the element data you're looking for \ud83d\ude2a. Luckily for you, the ",(0,r.kt)("inlineCode",{parentName:"p"},"IfcRelationsIndexer")," already gives you an easy way to get the entities which are related with your elements thanks to the inverse attributes! \ud83d\udd25\ud83d\udd25"),(0,r.kt)("h3",{id:"loading-a-model-"},"Loading a model \ud83c\udfe6"),(0,r.kt)("p",null,"First things first, lets load an IFC model to process its relations."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If you're unsure on the details to load a model, just tool at the ",(0,r.kt)("a",{parentName:"p",href:"/Tutorials/Components/Core/IfcLoader"},"IfcLoader")," tutorial!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const ifcLoader = components.get(OBC.IfcLoader);\nawait ifcLoader.setup();\nconst file = await fetch("/resources/small.ifc");\nconst buffer = await file.arrayBuffer();\nconst typedArray = new Uint8Array(buffer);\nconst model = await ifcLoader.load(typedArray);\nworld.scene.three.add(model);\n')),(0,r.kt)("p",null,"Once the model is loaded in memory, you just need to get an instance of the IfcRelationsIndexer and process the model... it's as easy as that! \ud83d\ude0e"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const indexer = components.get(OBC.IfcRelationsIndexer);\nawait indexer.process(model);\n")),(0,r.kt)("p",null,"The result of that is basically a map where the keys are the expressIDs and the values are other expressIDs related to the first one and grouped by the type of relation. You don't need to worry too much about the details of that, as the usage is pretty straighforward \ud83d\udd1d. The only thing that matters is you've now an easy way to access the entities related to your element \ud83d\ude42"),(0,r.kt)("h3",{id:"getting-element-psets-"},"Getting element psets \ud83d\udcc4"),(0,r.kt)("p",null,"One of the most important relations between different entities is the ",(0,r.kt)("inlineCode",{parentName:"p"},"IfcRelDefinesByProperties"),". That relation links together an arbitrary entity with a set of ",(0,r.kt)("inlineCode",{parentName:"p"},"IfcPropertySet")," entities that applies properties. Getting them with the ",(0,r.kt)("inlineCode",{parentName:"p"},"IfcRelationsIndexer")," once the model is indexed is pretty easy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const psets = indexer.getEntityRelations(model, 6518, "IsDefinedBy");\nif (psets) {\n  for (const expressID of psets) {\n    // You can get the pset attributes like this\n    const pset = await model.getProperties(expressID);\n    console.log(pset);\n    // You can get the pset props like this or iterate over pset.HasProperties yourself\n    await OBC.IfcPropertiesUtils.getPsetProps(\n      model,\n      expressID,\n      async (propExpressID) => {\n        const prop = await model.getProperties(propExpressID);\n        console.log(prop);\n      },\n    );\n  }\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"IsDefinedBy is the inverse attribute name in the IFC Schema that holds the relations with property sets \ud83d\ude09")),(0,r.kt)("p",null,"Awesome! really easy right?"),(0,r.kt)("h3",{id:"exporting-the-indexation"},"Exporting the indexation"),(0,r.kt)("p",null,"In bigger models, the process to calculate the relations index may take some time. The important thing is that there is no reason to calculate over and over the relations index every time you load a model. If the model hasn't change, their properties shouldn't neither! So, let's download the relations index to load it later."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const downloadJSON = (json: string, name: string) => {\n  const file = new File([json], name);\n  const a = document.createElement("a");\n  a.href = URL.createObjectURL(file);\n  a.download = file.name;\n  a.click();\n  URL.revokeObjectURL(a.href);\n};\n\nconst json = indexer.serializeModelRelations(model);\nconsole.log(json);\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"As ",(0,r.kt)("inlineCode",{parentName:"p"},"@thatopen/components")," can be used in either NodeJS and Browser environments, the logic to generate a JSON file may vary!")),(0,r.kt)("p",null,"Now, in case you've loaded several models and want to get all the computed relations, there is also a handy method to do it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const allRelationsJSON = indexer.serializeAllRelations();\n")),(0,r.kt)("h3",{id:"loading-back-the-relations-index"},"Loading back the relations index"),(0,r.kt)("p",null,"What do we gain with having a pre-processed relations index if we can't use it again, right? Well, let's use the downloaded relations index \ud83d\ude0e"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Lets first delete the existing model relations\ndelete indexer.relationMaps[model.uuid];\nconst relationsIndexFile = await fetch("/resources/small-relations.json");\nconst relationsIndex = indexer.getRelationsMapFromJSON(\n  await relationsIndexFile.text(),\n);\nindexer.setRelationMap(model, relationsIndex);\n')),(0,r.kt)("p",null,"Great! Now try to get again the property sets and you will see everything working nice and neat. In fact, lets try to get the building storey of one element in the IFC \ud83d\udc47"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const buildingStorey = indexer.getEntityRelations(\n  model,\n  6518,\n  "ContainedInStructure",\n);\n\nif (buildingStorey && buildingStorey[0]) {\n  const storey = await model.getProperties(buildingStorey[0]);\n  console.log(storey);\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Despite there are some relations that corresponds to only one element (e.g., an element can only have one associated building storey) the ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntityRelations")," will always return an array. That's the reason we take the first buildingStorey relation despite it will always be the only one.")),(0,r.kt)("p",null,"Congratulations! Now you know how to get an easy way to get the relations of your model. Keep going with more tutorials! \ud83d\udcaa"),(0,r.kt)("iframe",{src:"https://thatopen.github.io/engine_components/examples/IfcRelationsIndexer"}))}m.isMDXComponent=!0}}]);