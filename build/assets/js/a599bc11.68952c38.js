"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[835],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return n?o.createElement(f,i(i({ref:t},c),{},{components:n})):o.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7852:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>p,toc:()=>u});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),i=["components"],s={},l=void 0,p={unversionedId:"Tutorials/Components/Core/IfcPropertiesTiler",id:"Tutorials/Components/Core/IfcPropertiesTiler",title:"IfcPropertiesTiler",description:"Copying and pasting? We've got you covered! You can find the full source code of this tutorial here.",source:"@site/docs/Tutorials/Components/Core/IfcPropertiesTiler.mdx",sourceDirName:"Tutorials/Components/Core",slug:"/Tutorials/Components/Core/IfcPropertiesTiler",permalink:"/Tutorials/Components/Core/IfcPropertiesTiler",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IfcLoader",permalink:"/Tutorials/Components/Core/IfcLoader"},next:{title:"IfcRelationsIndexer",permalink:"/Tutorials/Components/Core/IfcRelationsIndexer"}},c={},u=[{value:"\ud83e\udde9 Tiling BIM properties",id:"-tiling-bim-properties",level:3},{value:"\ud83c\udf0e Setting up a simple scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83e\uddf3 Loading a BIM model",id:"-loading-a-bim-model",level:3},{value:"\u2198\ufe0f Setting up downloads",id:"\ufe0f-setting-up-downloads",level:3},{value:"\ud83d\udccb Getting the streamer",id:"-getting-the-streamer",level:3},{value:"\ud83d\udcc5 Setting up the events",id:"-setting-up-the-events",level:3},{value:"\ud83d\udd25 Generating the tiles",id:"-generating-the-tiles",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83e\udde9 Adding some UI",id:"-adding-some-ui",level:3},{value:"\ud83c\udf89 Wrap up",id:"-wrap-up",level:3}],m={toc:u},d="wrapper";function f(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)(d,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Source",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ThatOpen/engine_components/blob/main/packages/core/src/fragments/IfcPropertiesTiler/example.ts"},"here"),".")),(0,a.kt)("h3",{id:"-tiling-bim-properties"},"\ud83e\udde9 Tiling BIM properties"),(0,a.kt)("hr",null),(0,a.kt)("admonition",{title:"Tiles?",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"If you haven't checked out the geometry tiling tutorial, we recommend that you do it first! This tutorial assumes that you already have done it.")),(0,a.kt)("p",null,"You can also stream the properties of an IFC file. Why? Because some files can have\nmillions of properties, and trying to save them naively in a normal DB is not very\nscalable/affordable. Using this system, you'll be able to store and retrieve the\ndata of models of any size without big cloud costs.\nIn this tutorial, we will import:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"web-ifc")," to get some IFC items."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"@thatopen/components")," to set up the barebone of our app."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Stats.js")," (optional) to measure the performance of our app.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'import Stats from "stats.js";\nimport * as BUI from "@thatopen/ui";\nimport * as OBC from "@thatopen/components";\n')),(0,a.kt)("h3",{id:"-setting-up-a-simple-scene"},"\ud83c\udf0e Setting up a simple scene"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"We will start by creating a simple scene with a camera and a renderer. If you don't know how to set up a scene, you can check the Worlds tutorial."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const container = document.getElementById("container")!;\n\nconst components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\n\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.SimpleCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.SimpleCamera(components);\n\ncomponents.init();\n\nworld.camera.controls.setLookAt(12, 6, 8, 0, 0, -10);\n\nworld.scene.setup();\n\nconst grids = components.get(OBC.Grids);\ngrids.create(world);\n')),(0,a.kt)("p",null,"We'll make the background of the scene transparent so that it looks good in our docs page, but you don't have to do that in your app!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"world.scene.three.background = null;\n")),(0,a.kt)("h3",{id:"-loading-a-bim-model"},"\ud83e\uddf3 Loading a BIM model"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"We'll start by adding a BIM model to our scene. That model is already converted to fragments, so it will load much faster than if we loaded the IFC file."),(0,a.kt)("admonition",{title:"Fragments?",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"If you are not familiar with fragments, check out the IfcLoader tutorial!")),(0,a.kt)("p",null,"This is not compulsory, as the data will come from an .ifc file, not from fragments. But at least we'll see the model whose properties we will be converting to tiles!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const fragments = new OBC.FragmentsManager(components);\nconst fragFile = await fetch("https://thatopen.github.io/engine_components/resources/small.frag");\nconst fragData = await fragFile.arrayBuffer();\nconst fragBuffer = new Uint8Array(fragData);\nconst model = fragments.load(fragBuffer);\nworld.scene.three.add(model);\n')),(0,a.kt)("h3",{id:"\ufe0f-setting-up-downloads"},"\u2198\ufe0f Setting up downloads"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Now we will define some helper download functions that will allow us to get the property tiles that we generate in our computer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'function downloadFile(name: string, bits: Blob) {\n  const file = new File([bits], name);\n  const anchor = document.createElement("a");\n  const url = URL.createObjectURL(file);\n  anchor.href = url;\n  anchor.download = file.name;\n  anchor.click();\n  URL.revokeObjectURL(url);\n}\n\nasync function downloadFilesSequentially(\n  fileList: { name: string; bits: Blob }[],\n) {\n  for (const { name, bits } of fileList) {\n    downloadFile(name, bits);\n    await new Promise((resolve) => {\n      setTimeout(resolve, 100);\n    });\n  }\n}\n')),(0,a.kt)("h3",{id:"-getting-the-streamer"},"\ud83d\udccb Getting the streamer"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Now we will get the property streamer component from the library and initialize it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const propsStreamer = components.get(OBC.IfcPropertiesTiler);\n\npropsStreamer.settings.wasm = {\n  path: "https://unpkg.com/web-ifc@0.0.53/",\n  absolute: true,\n};\n')),(0,a.kt)("p",null,"We need to generate properties JSON with the following structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"interface StreamedProperties {\n  types: {\n    [typeID: number]: number[];\n  };\n\n  ids: {\n    [id: number]: number;\n  };\n\n  indexesFile: string;\n}\n")),(0,a.kt)("p",null,"So we will define an object where we will store the tiles as we generate them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const jsonFile: StreamedProperties = {\n  types: {},\n  ids: {},\n  indexesFile: "small.ifc-processed-properties-indexes",\n};\n')),(0,a.kt)("h3",{id:"-setting-up-the-events"},"\ud83d\udcc5 Setting up the events"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Similarly to geometries, here you will also get data and progress notification using events. In addition to properties, you will get ",(0,a.kt)("inlineCode",{parentName:"p"},"indices"),", which is an indexation data of the properties to be able to use them effectively when streamed. Let's set up those events now!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'let counter = 0;\n\nconst files: { name: string; bits: Blob }[] = [];\n\npropsStreamer.onPropertiesStreamed.add(async (props) => {\n  if (!jsonFile.types[props.type]) {\n    jsonFile.types[props.type] = [];\n  }\n  jsonFile.types[props.type].push(counter);\n\n  for (const id in props.data) {\n    jsonFile.ids[id] = counter;\n  }\n\n  const name = `small.ifc-processed-properties-${counter}`;\n  const bits = new Blob([JSON.stringify(props.data)]);\n  files.push({ bits, name });\n\n  counter++;\n});\n\npropsStreamer.onProgress.add(async (progress) => {\n  console.log(progress);\n});\n\npropsStreamer.onIndicesStreamed.add(async (props) => {\n  files.push({\n    name: `small.ifc-processed-properties.json`,\n    bits: new Blob([JSON.stringify(jsonFile)]),\n  });\n\n  const relations = components.get(OBC.IfcRelationsIndexer);\n  const serializedRels = relations.serializeRelations(props);\n\n  files.push({\n    name: "small.ifc-processed-properties-indexes",\n    bits: new Blob([serializedRels]),\n  });\n\n  await downloadFilesSequentially(files);\n});\n')),(0,a.kt)("h3",{id:"-generating-the-tiles"},"\ud83d\udd25 Generating the tiles"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Great! Now that we have everything setup, is time to finally convert the IFC file. In order to trigger the conversion, we can just do the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'async function processFile() {\n  const fetchedIfc = await fetch("https://thatopen.github.io/engine_components/resources/small.ifc");\n  const ifcBuffer = await fetchedIfc.arrayBuffer();\n  // We will need this information later to also convert the properties\n  const ifcArrayBuffer = new Uint8Array(ifcBuffer);\n  // This triggers the conversion, so the listeners start to be called\n  await propsStreamer.streamFromBuffer(ifcArrayBuffer);\n}\n')),(0,a.kt)("p",null,"If everything went as expected, you should now be seeing some files being downloaded from your app \ud83e\udd2f Do not get scary if they're a lot, as big models tend to have many files! All of that is the information the streaming uses in order to display the geometry in the most efficient way possible. \ud83d\udcaa"),(0,a.kt)("h3",{id:"\ufe0f-measuring-the-performance-optional"},"\u23f1\ufe0f Measuring the performance (optional)"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"We'll use the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/mrdoob/stats.js"},"Stats.js")," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n')),(0,a.kt)("h3",{id:"-adding-some-ui"},"\ud83e\udde9 Adding some UI"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"We will use the ",(0,a.kt)("inlineCode",{parentName:"p"},"@thatopen/ui")," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,a.kt)("inlineCode",{parentName:"p"},"init")," method of the ",(0,a.kt)("inlineCode",{parentName:"p"},"BUI.Manager")," class to initialize the library:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"BUI.Manager.init();\n")),(0,a.kt)("p",null,"Now we will add some UI to generate and download the tiles to our computer. For more information about the UI library, you can check the specific documentation for it!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const panel = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n  <bim-panel active label="Property Tiles Tutorial" class="options-menu">\n   <bim-panel-section collapsed label="Controls">\n      \n      <bim-panel-section style="padding-top: 12px;">\n      \n        <bim-button label="Load IFC"\n          @click="${() => {\n            processFile();\n          }}">\n        </bim-button>  \n      \n      </bim-panel-section>\n      \n    </bim-panel>\n  `;\n});\n\ndocument.body.append(panel);\n')),(0,a.kt)("p",null,"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n      <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n        @click="${() => {\n          if (panel.classList.contains("options-menu-visible")) {\n            panel.classList.remove("options-menu-visible");\n          } else {\n            panel.classList.add("options-menu-visible");\n          }\n        }}">\n      </bim-button>\n    `;\n});\n\ndocument.body.append(button);\n')),(0,a.kt)("h3",{id:"-wrap-up"},"\ud83c\udf89 Wrap up"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"That's it! You have created an app that can generate the property BIM tiles for an IFC and download them to your computer. Now you have the power to process big IFC files! To consume these tiles, check out the IFC streamer tutorial."),(0,a.kt)("iframe",{src:"https://thatopen.github.io/engine_components/examples/IfcPropertiesTiler"}))}f.isMDXComponent=!0}}]);